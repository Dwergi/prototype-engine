#version 330 core
#extension GL_OES_standard_derivatives : enable

out vec4 Colour;

in struct FragmentData
{
	vec3 Position;
	vec4 Colour;
	vec3 Barycentric;
} Fragment;

flat in vec3 FragmentNormal;

uniform bool DrawStandard;
uniform mat4 View;

uniform struct WireframeData
{
	bool Enabled;
	vec3 Colour;
	float Width;
	vec3 EdgeColour;
	float EdgeWidth;
	float MaxDistance;
}
Wireframe;

uniform struct MaterialData
{
	float Shininess;
	float Specular;
	float Diffuse;
	float Ambient;
}
Material;

#define MAX_LIGHTS 10

uniform struct LightData
{
	vec4 Position;
	vec3 Colour;
	float Intensity;
	float AmbientStrength;
	float SpecularStrength;
	float Attenuation;
}
Lights[ MAX_LIGHTS ];

uniform int LightCount;

#define MAX_HEIGHTS 10

uniform struct HeightLevel
{ 
	vec3 Colour;
	float Cutoff;
}
TerrainHeightLevels[ MAX_HEIGHTS ];

uniform float TerrainMaxHeight;
uniform int TerrainHeightCount;

uniform struct FogParameters
{
	vec3 Colour;
	float Distance;
	bool Enabled;
}
Fog;

//
// Gets the height colour based on TerrainHeightLevels.
// Iterates through until it reach a cutoff point that is larger than its height ratio,
// then mixes with the next colour based on the proportion of its height.
//
vec3 GetTerrainHeightColour( float heightPercent )
{
	int previous = 0;
	int current = 0;
	for( ; current < TerrainHeightCount; ++current )
	{
		if( heightPercent < TerrainHeightLevels[current].Cutoff )
			break;

		previous = current;
	}

	if( current == 0)
	{
		return TerrainHeightLevels[0].Colour;
	}

	float t = (heightPercent - TerrainHeightLevels[previous].Cutoff) / (TerrainHeightLevels[current].Cutoff - TerrainHeightLevels[previous].Cutoff);
	return mix( TerrainHeightLevels[previous].Colour, TerrainHeightLevels[current].Colour, t );
}

//
// Apply a single light to the pixel. 
// Deals with both directional and point lights.
//
vec3 ApplyLight( LightData light, MaterialData material, vec3 fragColour, vec3 fragNormal, vec3 fragPosition, vec3 viewDir )
{
	vec3 lightColour = light.Colour * light.Intensity;
	vec3 ambientColour = light.AmbientStrength * material.Ambient * lightColour;
	vec3 lightDir;

	float attenuation = 1.0;

	// directional lights
	if( light.Position.w == 0.0 )
	{
		lightDir = normalize( light.Position.xyz );
		attenuation = 1.0; 
	}
	else
	{
		vec3 fragmentToLight = light.Position.xyz - fragPosition;
		lightDir = normalize( fragmentToLight );
		float distanceToLight = length( fragmentToLight );
		attenuation = 1.0 / (1.0 + light.Attenuation * (distanceToLight * distanceToLight) );
	}

	float diffAmount = max( dot( fragNormal, lightDir ), 0.0 );
	vec3 diffuseColour = diffAmount * material.Diffuse * lightColour;

	vec3 reflectDir = reflect( -lightDir, fragNormal );
	float specularAmount = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.Shininess );
	vec3 specularColour = light.SpecularStrength * material.Specular * specularAmount * lightColour;

	vec3 linearColour = attenuation * (specularColour + diffuseColour) + ambientColour;
	vec3 finalColour = linearColour * fragColour;
	return finalColour;
}

//
// Calculate the colour of a pixel in wireframe mode by finding the minimum distance to an edge,
// and adding an edge of a different colour.
//
vec4 CalculateWireframe( vec3 barycentric, vec3 wireColour, float wireWidth, vec3 edgeColour, float edgeWidth, float viewDistance, float maxDistance )
{
	vec4 colour = vec4( 0.0 );

	if( viewDistance > maxDistance )
		return colour;

	wireWidth = mix( wireWidth, 0.0, viewDistance / maxDistance );
	edgeWidth = mix( edgeWidth, 0.0, viewDistance / maxDistance );

	vec3 d = fwidth( barycentric );
	vec3 tdist = smoothstep( vec3( 0.0 ), d * wireWidth, barycentric );
	float t = min( min( tdist.x, tdist.y ), tdist.z );

	float edge_ratio = edgeWidth / wireWidth;

	if( edge_ratio > 0 )
	{
		float edge_t = clamp( (t - (1.0 - edge_ratio)) / edge_ratio, 0.0, 1.0 );
		colour = mix( vec4( edgeColour, 1 ), vec4( 0.0 ), edge_t );
	}

	if( edge_ratio < 1 )
	{
		float wire_t = clamp( t / (1.0 - edge_ratio), 0.0, 1.0 );
		colour = mix( vec4( wireColour, 1 ), colour, wire_t );
	}

	return colour;
}

void main()
{
	vec3 toView = View[ 3 ].xyz - Fragment.Position;
	float viewDistance = length( toView );

	float fogAmount = clamp( viewDistance / Fog.Distance, 0, 1 );
	fogAmount = fogAmount * fogAmount;

	if( fogAmount >= 1 )
	{
		Colour = vec4( Fog.Colour, 1 );
		return;
	}

	vec4 finalColour = vec4( 0 );

	if( DrawStandard )
	{
		vec3 fragmentColour = Fragment.Colour.rgb;
		if( TerrainHeightCount > 0 )
		{
			fragmentColour *= GetTerrainHeightColour( Fragment.Position.y / TerrainMaxHeight );
		}

		vec3 normal = normalize( FragmentNormal );
		vec3 viewDir = normalize( toView );
		for( int i = 0; i < LightCount; ++i )
		{
			finalColour.rgb += ApplyLight( Lights[ i ], Material, fragmentColour, normal, Fragment.Position, viewDir );
		}
		
		vec3 gamma = vec3( 1.0 / 2.2 );
    	finalColour.rgb = pow( finalColour.rgb, gamma );
		finalColour.a = Fragment.Colour.a;
	}

	if( Wireframe.Enabled )
	{
		vec4 wireColour = CalculateWireframe( Fragment.Barycentric, Wireframe.Colour, Wireframe.Width, 
			Wireframe.EdgeColour, Wireframe.EdgeWidth, viewDistance, Wireframe.MaxDistance );

		finalColour = mix( finalColour, wireColour, wireColour.a );
	}

	if( Fog.Enabled )
	{
		finalColour = mix( finalColour, vec4( Fog.Colour, 1 ), fogAmount );
	}

	Colour = finalColour;
}
