#version 330 core

out vec4 Colour;

in struct FragmentData
{
	vec3 Position;
	vec4 Colour;
}
Fragment;

flat in vec3 FragmentNormal;

uniform mat4 View;

uniform struct MaterialData
{
	float Shininess;
	float Specular;
	float Diffuse;
	float Ambient;
} 
Material;

#define MAX_LIGHTS 10

uniform struct LightData 
{
	int Type; // 0 = directional, 1 = point, 2 = spot
	vec4 Position;
	vec3 Direction;
	vec3 Colour;
	float CosInnerAngle;
	float CosOuterAngle;
	float Intensity;
	float AmbientStrength;
	float SpecularStrength;
	float Attenuation;
} 
Lights[ MAX_LIGHTS ];

uniform int LightCount;

uniform struct FogParameters
{
	vec3 Colour;
	float Distance;
	bool Enabled;
}
Fog;

uniform bool DrawNormals;

//
// Apply a single light to the pixel. 
// Deals with both directional and point lights.
//
vec3 ApplyLight( LightData light, MaterialData material, vec3 fragColour, vec3 fragNormal, vec3 fragPosition, vec3 viewDir )
{
	vec3 lightColour = light.Colour * light.Intensity;
	vec3 ambientColour = light.AmbientStrength * material.Ambient * lightColour;
	vec3 lightDir;

	float attenuation = 1.0;

	if( light.Type == 0 )
	{
		// directional lights
		attenuation = 1.0; 
	}
	else if( light.Type == 1 )
	{
		// point lights
		vec3 fragmentToLight = light.Position.xyz - fragPosition;
		lightDir = normalize( fragmentToLight );
		float distanceToLight = length( fragmentToLight );
		attenuation = 1.0 / (1.0 + light.Attenuation * (distanceToLight * distanceToLight) );
	}
	else if( light.Type == 2 )
	{
		// spot lights
		vec3 fragmentToLight = light.Position.xyz - fragPosition;
		lightDir = normalize( fragmentToLight );

		float theta = dot( lightDir, -light.Direction );
		float epsilon = light.CosInnerAngle - light.CosOuterAngle;
		float intensity = clamp( (theta - light.CosOuterAngle) / epsilon, 0.0, 1.0 );

		float distanceToLight = length( fragmentToLight );
		attenuation = 1.0 / (1.0 + light.Attenuation * (distanceToLight * distanceToLight) );
		attenuation *= intensity;
	}

	float diffAmount = max( dot( fragNormal, lightDir ), 0.0 );
	vec3 diffuseColour = diffAmount * material.Diffuse * lightColour;

	vec3 reflectDir = reflect( -lightDir, fragNormal );
	float specularAmount = pow( max( dot( viewDir, reflectDir ), 0.0 ), material.Shininess );
	vec3 specularColour = light.SpecularStrength * material.Specular * specularAmount * lightColour;

	vec3 linearColour = attenuation * (specularColour + diffuseColour) + ambientColour;
	vec3 finalColour = linearColour * fragColour;
	return finalColour;
}


void main()
{
	if( DrawNormals )
	{
		Colour = vec4( FragmentNormal, 1 );
		return;
	}

	vec3 toView = View[ 3 ].xyz - Fragment.Position;
	float viewDistance = length( toView );

	float fogAmount = clamp( viewDistance / Fog.Distance, 0, 1 );
	fogAmount = fogAmount * fogAmount;

	if( fogAmount >= 1 )
	{
		Colour = vec4( Fog.Colour, 1 );
		return;
	}

	vec4 finalColour = vec4( 0 );
	
	vec3 fragmentColour = Fragment.Colour.rgb;

	vec3 normal = normalize( FragmentNormal );
	vec3 viewDir = normalize( toView );
	for( int i = 0; i < LightCount; ++i )
	{
		finalColour.rgb += ApplyLight( Lights[ i ], Material, fragmentColour, normal, Fragment.Position, viewDir );
	}
	
	vec3 gamma = vec3( 1.0 / 2.2 );
	finalColour.rgb = pow( finalColour.rgb, gamma );
	finalColour.a = Fragment.Colour.a;

	if( Fog.Enabled )
	{
		finalColour = mix( finalColour, vec4( Fog.Colour, 1 ), fogAmount );
	}

	Colour = finalColour;
}
